name: CI - Quality Checks

on:
  pull_request:
    branches: [main, dev]
  push:
    branches: [main, dev]
  workflow_dispatch:

# Cancelar runs anteriores da mesma branch/PR
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  quality:
    name: Code Quality & Build
    runs-on: ubuntu-latest
    timeout-minutes: 15

    strategy:
      matrix:
        node-version: [20.x]

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v6
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Generate Prisma Client
        run: npm run prisma:generate
        env:
          # Usar DATABASE_URL fake para geração do cliente (não precisa de DB real)
          DATABASE_URL: postgresql://user:pass@localhost:5432/db?schema=public
          DIRECT_URL: postgresql://user:pass@localhost:5432/db?schema=public

      - name: Validate Prisma Schema
        run: npm run prisma:validate
        env:
          DATABASE_URL: postgresql://user:pass@localhost:5432/db?schema=public
          DIRECT_URL: postgresql://user:pass@localhost:5432/db?schema=public

      - name: Type Check
        run: npm run type-check

      - name: Lint
        run: npm run lint

      - name: Run Tests
        run: npm run test:ci
        continue-on-error: true # Não falha se não houver testes ainda

      - name: Build Application
        run: npm run build
        env:
          # Variáveis mínimas necessárias para build (Next.js requer algumas env vars)
          NEXTAUTH_URL: http://localhost:3000
          NEXTAUTH_SECRET: test-secret-for-ci-build-only
          DATABASE_URL: postgresql://user:pass@localhost:5432/db?schema=public
          DIRECT_URL: postgresql://user:pass@localhost:5432/db?schema=public
          # Stripe (valores fake para build)
          STRIPE_SECRET_KEY: sk_test_fake
          NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY: pk_test_fake
          # Desabilitar telemetria em CI
          NEXT_TELEMETRY_DISABLED: 1

      - name: Check for build errors
        if: failure()
        run: |
          echo "::error::Build failed! Check the logs above for details."
          exit 1

  # Job separado para validar dependências
  dependencies:
    name: Dependency Validation
    runs-on: ubuntu-latest
    timeout-minutes: 5

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: 20.x
          cache: 'npm'

      - name: Check for lockfile changes
        run: |
          if git diff --name-only ${{ github.event.before }} ${{ github.sha }} | grep -q "package-lock.json"; then
            echo "package-lock.json was modified"
            echo "LOCKFILE_CHANGED=true" >> $GITHUB_ENV
          else
            echo "package-lock.json was not modified"
            echo "LOCKFILE_CHANGED=false" >> $GITHUB_ENV
          fi

      - name: Install dependencies
        run: npm ci

      - name: Verify lockfile integrity
        run: |
          npm ci --prefer-offline
          git diff --exit-code package-lock.json || (echo "::error::package-lock.json is out of sync. Run 'npm install' locally and commit the changes." && exit 1)

  # Job para validar formato de commits (Conventional Commits)
  commit-lint:
    name: Commit Message Validation
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    timeout-minutes: 5

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Validate commit messages
        run: |
          echo "Checking commit messages format..."
          # Verifica se os commits seguem o padrão básico: type(scope): message
          # Tipos aceitos: feat, fix, docs, style, refactor, perf, test, chore, ci

          COMMITS=$(git log --pretty=format:"%s" origin/${{ github.base_ref }}..HEAD)

          VALID_PATTERN="^(feat|fix|docs|style|refactor|perf|test|chore|ci|build|revert)(\(.+\))?: .{1,}"

          INVALID_COMMITS=""
          while IFS= read -r commit; do
            if ! echo "$commit" | grep -qE "$VALID_PATTERN"; then
              INVALID_COMMITS="${INVALID_COMMITS}\n- ${commit}"
            fi
          done <<< "$COMMITS"

          if [ -n "$INVALID_COMMITS" ]; then
            echo "::warning::Some commits don't follow Conventional Commits format:"
            echo -e "$INVALID_COMMITS"
            echo ""
            echo "Expected format: type(scope): description"
            echo "Types: feat, fix, docs, style, refactor, perf, test, chore, ci, build, revert"
            # Apenas warning, não falha o CI
          else
            echo "✓ All commits follow Conventional Commits format"
          fi

  # Status check final (requerido para merge)
  ci-success:
    name: CI Success
    runs-on: ubuntu-latest
    needs: [quality, dependencies]
    if: always()

    steps:
      - name: Check all jobs
        run: |
          if [ "${{ needs.quality.result }}" != "success" ] || [ "${{ needs.dependencies.result }}" != "success" ]; then
            echo "::error::One or more CI jobs failed"
            exit 1
          fi
          echo "✓ All CI checks passed successfully"
